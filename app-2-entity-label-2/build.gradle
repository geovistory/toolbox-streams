/* 2
 * This file was generated by the Gradle 'init' task.
 */

plugins {
    id 'org.geovistory.toolbox.streams.java-application-conventions'

    // used to set semantic version
    id 'com.glovoapp.semantic-versioning' version '1.1.10'

    // Used to containerize apps
    id 'com.google.cloud.tools.jib' version '3.3.0'

    id 'io.quarkus'

    // Used to build java class source code from avro schemas
    id "com.github.davidmc24.gradle.plugin.avro" version "1.5.0"

}

dependencies {

    // For gradle-avro-plugin
    implementation "org.apache.avro:avro:1.11.0"
    // for .env
    implementation 'io.github.cdimascio:dotenv-java:2.2.4'

    // Confluent Avro Serdes
    implementation(group: 'io.confluent', name: 'kafka-streams-avro-serde', version: '7.3.2') {
        exclude group: 'org.apache.kafka', module: 'kafka-clients'
    }

    implementation 'io.quarkus:quarkus-resteasy-reactive-jackson'

    // Added for test with embedded redpanda broker
    testImplementation "org.testcontainers:redpanda:1.19.0"

    // Added for testing rest endpoints
    testImplementation "io.rest-assured:rest-assured"

}

application {
    // Define the main class for the application.
    mainClassName = 'org.geovistory.toolbox.streams.entity.label2.App'
}


jar {
    manifest.attributes('Main-Class': application.mainClassName)
}
/**
 * Get docker image tag
 * @return for example "ghcr.io/geovistory/toolbox-streams-entity-label-2:0.1.0"
 */
String getDockerImageTag() {
    return 'ghcr.io/geovistory/toolbox-streams-entity-label-2' + ':' + getDockerTagSuffix()
}

/**
 * Get docker tag suffix from semantic version and pull request metadata.
 * @return for example "0.2.3" or "0.1.0-pr-12.0"
 */
String getDockerTagSuffix() {
    if (pullRequestNumber) return "${project.semanticVersion.version.get()}-pr-${pullRequestNumber}.${pullRequestPushCount}"
    else return "${project.semanticVersion.version.get()}"
}


task("printDockerImageTag") {
    doLast {
        println getDockerImageTag()
    }
}

task("printDockerTagSuffix") {
    doLast {
        println getDockerTagSuffix()
    }
}


// inspired by https://discuss.gradle.org/t/how-to-get-gradle-variables-in-my-java-method/37580/2
task generateJava {
    ext.outputDir = "$buildDir/generated/java"
    outputs.dir outputDir
    doLast {
        mkdir "$outputDir/org/geovistory/toolbox/streams/entity/label2"
        file("$outputDir/org/geovistory/toolbox/streams/entity/label2/BuildProperties.java").text =
                """|package org.geovistory.toolbox.streams.entity.label2;
               |public class BuildProperties {
               |    public static String getDockerTagSuffix() { return "${getDockerTagSuffix()}"; }
               |    public static String getDockerImageTag() { return "${getDockerImageTag()}"; }
               |}""".stripMargin()
    }
}


task generateReflectionConfiguration {
    ext.outputDir = "$buildDir/generated/java"
    outputs.dir outputDir
    doFirst {
        var classNames = new ArrayList<String>()

        classNames.add("ts.projects.info_proj_rel.Key.class")
        classNames.add("ts.projects.info_proj_rel.Value.class")
        classNames.add("ts.information.resource.Key.class")
        classNames.add("ts.information.resource.Value.class")
        classNames.add("EdgeValue.class")
        classNames.add("EntityProjectedValue.class")
        classNames.add("EntityValue.class")
        classNames.add("IprJoinVal.class")
        classNames.add("IprValue.class")
        classNames.add("StatementJoinValue.class")
        classNames.add("StatementValue.class")
        classNames.add("StatementWithSubValue.class")
        classNames.add("org.geovistory.toolbox.streams.lib.jsonmodels.CommunityVisibility.class")
        classNames.add("EntityLabelConfig.class")
        classNames.add("EntityLabelConfigPart.class")
        classNames.add("EntityLabelConfigPartField.class")
        classNames.add("ProjectStatementValue.class")
        classNames.add("ProjectEntityValue.class")
        classNames.add("ProjectEntityLabelConfigValue.class")
        classNames.add("DR.class")
        classNames.add("CommunityStatementValue.class")
        classNames.add("CommunityEntityValue.class")
        classNames.add("io.debezium.data.geometry.Geography.class")
        classNames.add("Entity.class")
        classNames.add("Language.class")
        classNames.add("Appellation.class")
        classNames.add("LangString.class")
        classNames.add("Place.class")
        classNames.add("TimePrimitive.class")
        classNames.add("Dimension.class")
        classNames.add("Cell.class")
        classNames.add("Digital.class")
        classNames.add("NodeKey.class")
        classNames.add("NodeValue.class")

        mkdir "$outputDir/org/geovistory/toolbox/streams/entity/label2"
        file("$outputDir/org/geovistory/toolbox/streams/entity/label2/ReflectionConfig.java").text =
                """|package org.geovistory.toolbox.streams.entity.label2;
                |
                |import io.quarkus.runtime.annotations.RegisterForReflection;
                |import org.geovistory.toolbox.streams.avro.*;
                |
                |@RegisterForReflection(targets = {
                |   """.stripMargin() +
                        classNames.toArray().toUnique().join(",\n|   ").stripMargin() +
                        """|})
                |public class ReflectionConfig {
                |}""".stripMargin()
    }
}

compileJava {
    dependsOn(generateReflectionConfiguration)
    dependsOn(generateJava)
}
sourceSets.main.java.srcDir generateReflectionConfiguration.outputDir
sourceSets.main.java.srcDir generateJava.outputDir

private static void createExtendingAvroClass(String filePath, String newPackageName, String className, String oldFullName) {

    var myFile = new File(filePath)
    myFile.createNewFile()
    var newText = "package " + newPackageName + ";\n" +
            "import io.quarkus.runtime.annotations.RegisterForReflection;\n" +
            "@RegisterForReflection\n" +
            "public class " + className + " extends " + oldFullName +
            " implements org.apache.avro.specific.SpecificRecord { }"
    myFile.write(newText)
}