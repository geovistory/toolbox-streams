package org.geovistory.toolbox.streams.app;

import org.apache.kafka.common.serialization.Serde;
import org.apache.kafka.common.utils.Bytes;
import org.apache.kafka.streams.KeyValue;
import org.apache.kafka.streams.StreamsBuilder;
import org.apache.kafka.streams.kstream.*;
import org.apache.kafka.streams.state.KeyValueStore;
import org.geovistory.toolbox.streams.lib.ConfluentAvroSerdes;

/**
 * This class provides helper methods to register
 * source topics (topics consumed but not generated by this app)
 */
public class RegisterInputTopic {
    public StreamsBuilder builder;
    public ConfluentAvroSerdes avroSerdes;

    public RegisterInputTopic(StreamsBuilder builder) {
        this.builder = builder;
        this.avroSerdes = new ConfluentAvroSerdes();
    }

    public KTable<dev.projects.project.Key, dev.projects.project.Value> proProjectTable() {
        return getRepartitionedTable(
                DbTopicNames.pro_projects.getName(),
                avroSerdes.ProProjectKey(),
                avroSerdes.ProProjectValue()
        );
    }

    public KStream<dev.projects.text_property.Key, dev.projects.text_property.Value> proTextPropertyStream() {
        return getRepartitionedStream(
                DbTopicNames.pro_text_property.getName(),
                avroSerdes.ProTextPropertyKey(),
                avroSerdes.ProTextPropertyValue()
        );
    }

    public KTable<dev.projects.dfh_profile_proj_rel.Key, dev.projects.dfh_profile_proj_rel.Value> proProfileProjRelTable() {
        return getRepartitionedTable(
                DbTopicNames.pro_dfh_profile_proj_rel.getName(),
                avroSerdes.ProProfileProjRelKey(),
                avroSerdes.ProProfileProjRelValue()
        );
    }

    public KTable<dev.projects.info_proj_rel.Key, dev.projects.info_proj_rel.Value> proInfoProjRelTable() {
        return getRepartitionedTable(
                DbTopicNames.pro_info_proj_rel.getName(),
                avroSerdes.ProInfoProjRelKey(),
                avroSerdes.ProInfoProjRelValue()
        );
    }


    public KTable<dev.information.resource.Key, dev.information.resource.Value> infResourceTable() {
        return getRepartitionedTable(
                DbTopicNames.inf_resource.getName(),
                avroSerdes.InfResourceKey(),
                avroSerdes.InfResourceValue()
        );
    }

    public KStream<dev.information.resource.Key, dev.information.resource.Value> infResourceStream() {
        return getStream(
                DbTopicNames.inf_resource.getName(),
                avroSerdes.InfResourceKey(),
                avroSerdes.InfResourceValue()
        );
    }


    public KTable<dev.information.statement.Key, dev.information.statement.Value> infStatementTable() {
        return getRepartitionedTable(
                DbTopicNames.inf_statement.getName(),
                avroSerdes.InfStatementKey(),
                avroSerdes.InfStatementValue()
        );
    }

    public KTable<dev.system.config.Key, dev.system.config.Value> sysConfigTable() {
        return getRepartitionedTable(
                DbTopicNames.sys_config.getName(),
                avroSerdes.SysConfigKey(),
                avroSerdes.SysConfigValue()
        );
    }

    public KStream<dev.projects.entity_label_config.Key, dev.projects.entity_label_config.Value> proEntityLabelConfigStream() {
        return getStream(
                DbTopicNames.pro_entity_label_config.getName(),
                avroSerdes.ProEntityLabelConfigKey(),
                avroSerdes.ProEntityLabelConfigValue()
        );
    }

    public KStream<dev.information.language.Key, dev.information.language.Value> infLanguageStream() {
        return getStream(
                DbTopicNames.inf_language.getName(),
                avroSerdes.InfLanguageKey(),
                avroSerdes.InfLanguageValue()
        );
    }

    public KStream<dev.information.appellation.Key, dev.information.appellation.Value> infAppellationStream() {
        return getStream(
                DbTopicNames.inf_appellation.getName(),
                avroSerdes.InfAppellationKey(),
                avroSerdes.InfAppellationValue()
        );
    }

    public KStream<dev.information.lang_string.Key, dev.information.lang_string.Value> infLangStringStream() {
        return getStream(
                DbTopicNames.inf_lang_string.getName(),
                avroSerdes.InfLangStringKey(),
                avroSerdes.InfLangStringValue()
        );
    }

    public KStream<dev.information.place.Key, dev.information.place.Value> infPlaceStream() {
        return getStream(
                DbTopicNames.inf_place.getName(),
                avroSerdes.InfPlaceKey(),
                avroSerdes.InfPlaceValue()
        );
    }

    public KStream<dev.information.time_primitive.Key, dev.information.time_primitive.Value> infTimePrimitiveStream() {
        return getStream(
                DbTopicNames.inf_time_primitive.getName(),
                avroSerdes.InfTimePrimitiveKey(),
                avroSerdes.InfTimePrimitiveValue()
        );
    }

    public KStream<dev.information.dimension.Key, dev.information.dimension.Value> infDimensionStream() {
        return getStream(
                DbTopicNames.inf_dimension.getName(),
                avroSerdes.InfDimensionKey(),
                avroSerdes.InfDimensionValue()
        );
    }

    public KStream<dev.data.digital.Key, dev.data.digital.Value> datDigitalStream() {
        return getStream(
                DbTopicNames.dat_digital.getName(),
                avroSerdes.DatDigitalKey(),
                avroSerdes.DatDigitalValue()
        );
    }

    public KStream<dev.tables.cell.Key, dev.tables.cell.Value> tabCellStream() {
        return getStream(
                DbTopicNames.tab_cell.getName(),
                avroSerdes.TabCellKey(),
                avroSerdes.TabCellValue()
        );
    }


    /**
     * Register a KStream and map it to a new KTable to ensure proper partitioning
     * This seems to be needed to correctly join topics created by debezium, since they have
     * a different Partitioner then this Kafka Streams application.
     *
     * @param topicName name of topic to consume from
     * @param kSerde    key Serde
     * @param vSerde    value Serde
     * @return KTable
     */
    private <K, V> KTable<K, V> getRepartitionedTable(String topicName, Serde<K> kSerde, Serde<V> vSerde) {

        return getStream(topicName, kSerde, vSerde)
                .map(KeyValue::pair, Named.as(topicName + "-mark-for-repartition"))
                .toTable(
                        Named.as(topicName + "-to-table"),
                        Materialized
                                .<K, V, KeyValueStore<Bytes, byte[]>>as(topicName + "-store")
                                .withKeySerde(kSerde)
                                .withValueSerde(vSerde)
                );
    }


    private <K, V> KStream<K, V> getStream(String topicName, Serde<K> kSerde, Serde<V> vSerde) {
        return builder.stream(topicName, Consumed.with(kSerde, vSerde).withName(topicName + "-consumer"));
    }

    private <K, V> KStream<K, V> getRepartitionedStream(String topicName, Serde<K> kSerde, Serde<V> vSerde) {
        return getStream(topicName, kSerde, vSerde)
                .map(KeyValue::pair, Named.as(topicName + "-mark-for-repartition"))
                .repartition(
                        Repartitioned.<K, V>as(topicName + "-repartitioned")
                                .withKeySerde(kSerde)
                                .withValueSerde(vSerde)
                );
    }
}