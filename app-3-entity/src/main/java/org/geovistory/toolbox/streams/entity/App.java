/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.geovistory.toolbox.streams.entity;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.inject.Produces;
import jakarta.inject.Inject;
import org.apache.kafka.common.serialization.Serdes;
import org.apache.kafka.streams.StreamsBuilder;
import org.apache.kafka.streams.Topology;
import org.apache.kafka.streams.kstream.KTable;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.geovistory.toolbox.streams.avro.OntomeClassKey;
import org.geovistory.toolbox.streams.avro.OntomeClassMetadataValue;
import org.geovistory.toolbox.streams.entity.names.ProcessorNames;
import org.geovistory.toolbox.streams.entity.names.SinkNames;
import org.geovistory.toolbox.streams.entity.names.SourceNames;
import org.geovistory.toolbox.streams.entity.processors.CreateTimeSpans;
import org.geovistory.toolbox.streams.entity.processors.community.CommunityEntityClassLabel;
import org.geovistory.toolbox.streams.entity.processors.community.CommunityEntityClassMetadata;
import org.geovistory.toolbox.streams.entity.processors.project.ProjectEntityClassLabel;
import org.geovistory.toolbox.streams.entity.processors.project.ProjectEntityClassMetadata;
import org.geovistory.toolbox.streams.entity.stores.TimePrimitiveSortKeyStore;
import org.geovistory.toolbox.streams.entity.stores.TimePrimitiveStore;
import org.geovistory.toolbox.streams.lib.TsAdmin;

import java.util.ArrayList;
import java.util.Objects;


@ApplicationScoped
public class App {

    @ConfigProperty(name = "ts.output.topic.partitions")
    int outputTopicPartitions;
    @ConfigProperty(name = "ts.output.topic.replication.factor")
    short outputTopicReplicationFactor;

    @ConfigProperty(name = "quarkus.kafka.streams.bootstrap.servers")
    String bootstrapServers;
    @Inject
    ConfiguredAvroSerde as;

    @Inject
    ProjectEntityClassLabel projectEntityClassLabel;
    @Inject
    ProjectEntityClassMetadata projectEntityClassMetadata;

    @Inject
    CommunityEntityClassLabel communityEntityClassLabel;
    @Inject
    CommunityEntityClassMetadata communityEntityClassMetadata;

    @Inject
    BuilderSingleton builderSingleton;
    @Inject
    RegisterInputTopic registerInputTopic;
    @Inject
    OutputTopicNames outputTopicNames;
    @Inject
    InputTopicNames inputTopicNames;

    @Inject
    TimePrimitiveSortKeyStore timePrimitiveSortKeyStore;

    @Inject
    TimePrimitiveStore timePrimitiveStore;

    @ConfigProperty(name = "auto.create.output.topics")
    String autoCreateOutputTopics;


    //  All we need to do for that is to declare a CDI producer method which returns the Kafka Streams Topology; the Quarkus extension will take care of configuring, starting and stopping the actual Kafka Streams engine.
    @Produces
    public Topology buildTopology() {

        builderSingleton.builder = new StreamsBuilder();

        // add processors of sub-topologies
        var t = addSubTopologies();

        // create output topics in advance to ensure correct configuration (partition, compaction, ect.)
        if (Objects.equals(autoCreateOutputTopics, "enabled")) createTopics();

        // build the topology
        return t;
    }


    private Topology addSubTopologies() {

        var ontomeClassMetadataTable = registerInputTopic.ontomeClassMetadataTable();
        addProjectView(ontomeClassMetadataTable);
        addCommunityToolboxView(ontomeClassMetadataTable);
        var topology = builderSingleton.builder.build();

        topology
                // Project Time Spans
                .addSource(SourceNames.PROJECT_EDGES, Serdes.String().deserializer(), as.vD(), inputTopicNames.getProjectEdges())
                .addProcessor(ProcessorNames.CREATE_PROJECT_TIME_SPAN, () -> new CreateTimeSpans("p"), SourceNames.PROJECT_EDGES)
                .addSink(SinkNames.SINK_TIME_SPAN_PROJECT, outputTopicNames.projectEntityTimeSpan(), as.kS(), as.vS(), ProcessorNames.CREATE_PROJECT_TIME_SPAN)
                // Community Time Spans
                .addSource(SourceNames.COMMUNITY_EDGES, Serdes.String().deserializer(), as.vD(), inputTopicNames.getCommunityEdges())
                .addProcessor(ProcessorNames.CREATE_COMMUNITY_TIME_SPAN, () -> new CreateTimeSpans("c"), SourceNames.COMMUNITY_EDGES)
                .addSink(SinkNames.SINK_TIME_SPAN_COMMUNITY, outputTopicNames.communityEntityTimeSpan(), as.kS(), as.vS(), ProcessorNames.CREATE_COMMUNITY_TIME_SPAN)
                // Stores
                .addStateStore(timePrimitiveSortKeyStore.createPersistentKeyValueStore(), ProcessorNames.CREATE_COMMUNITY_TIME_SPAN, ProcessorNames.CREATE_PROJECT_TIME_SPAN)
                .addStateStore(timePrimitiveStore.createPersistentKeyValueStore(), ProcessorNames.CREATE_COMMUNITY_TIME_SPAN, ProcessorNames.CREATE_PROJECT_TIME_SPAN);


        return topology;

    }

    private void createTopics() {
        var admin = new TsAdmin(bootstrapServers);

        createTopicsForProjectView(admin);
        createTopicsForCommunityView(admin);

    }

    private void addProjectView(
            KTable<OntomeClassKey, OntomeClassMetadataValue> ontomeClassMetadataTable
    ) {
        // register input topics as KTables
        var projectEntityTable = registerInputTopic.projectEntityTable();

        // register input topics as KStreams
        var projectClassLabelTable = registerInputTopic.projectClassLabelTable();


        // add sub-topology ProjectEntityClassLabel
        projectEntityClassLabel.addProcessors(
                projectEntityTable,
                projectClassLabelTable
        );

        // add sub-topology ProjectEntityClassMetadata
        projectEntityClassMetadata.addProcessors(
                projectEntityTable,
                ontomeClassMetadataTable
        );
    }

    private void addCommunityToolboxView(
            KTable<OntomeClassKey, OntomeClassMetadataValue> ontomeClassMetadataTable
    ) {
        // register input topics as KTables
        var communityEntityTable = registerInputTopic.communityEntityTable();


        // register input topics as KStreams
        var communityClassLabelTable = registerInputTopic.communityClassLabelTable();


        // add sub-topology CommunityEntityClassLabel
        communityEntityClassLabel.addProcessors(
                communityEntityTable,
                communityClassLabelTable
        );

        // add sub-topology CommunityEntityClassMetadata
        communityEntityClassMetadata.addProcessors(
                communityEntityTable,
                ontomeClassMetadataTable
        );
    }


    private void createTopicsForProjectView(TsAdmin admin) {
        // create output topics (with number of partitions and delete.policy=compact)
        var topics = new ArrayList<String>();
        topics.add(outputTopicNames.projectEntityClassLabel());
        topics.add(outputTopicNames.projectEntityTimeSpan());
        topics.add(outputTopicNames.projectEntityClassMetadata());
        topics.add(outputTopicNames.projectEntityType());
        admin.createOrConfigureTopics(topics, outputTopicPartitions, outputTopicReplicationFactor);
    }


    private void createTopicsForCommunityView(TsAdmin admin) {
        // create output topics (with number of partitions and delete.policy=compact)
        var topics = new ArrayList<String>();
        topics.add(outputTopicNames.communityEntityClassLabel());
        topics.add(outputTopicNames.communityEntityTimeSpan());
        topics.add(outputTopicNames.communityEntityClassMetadata());
        topics.add(outputTopicNames.communityEntityType());
        admin.createOrConfigureTopics(topics, outputTopicPartitions, outputTopicReplicationFactor);
    }


}
