/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.geovistory.toolbox.streams.entity;

import org.apache.kafka.streams.Topology;
import org.apache.kafka.streams.kstream.KTable;
import org.apache.kafka.streams.kstream.Named;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.geovistory.toolbox.streams.avro.HasTypePropertyKey;
import org.geovistory.toolbox.streams.avro.HasTypePropertyValue;
import org.geovistory.toolbox.streams.avro.OntomeClassKey;
import org.geovistory.toolbox.streams.avro.OntomeClassMetadataValue;
import org.geovistory.toolbox.streams.entity.processors.community.CommunityEntityClassLabel;
import org.geovistory.toolbox.streams.entity.processors.community.CommunityEntityClassMetadata;
import org.geovistory.toolbox.streams.entity.processors.community.CommunityEntityTimeSpan;
import org.geovistory.toolbox.streams.entity.processors.community.CommunityEntityType;
import org.geovistory.toolbox.streams.entity.processors.project.ProjectEntityClassLabel;
import org.geovistory.toolbox.streams.entity.processors.project.ProjectEntityClassMetadata;
import org.geovistory.toolbox.streams.entity.processors.project.ProjectEntityTimeSpan;
import org.geovistory.toolbox.streams.entity.processors.project.ProjectEntityType;
import org.geovistory.toolbox.streams.lib.TsAdmin;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.inject.Produces;
import jakarta.inject.Inject;
import java.util.ArrayList;


@ApplicationScoped
public class App {

    @ConfigProperty(name = "ts.output.topic.partitions")
    int outputTopicPartitions;
    @ConfigProperty(name = "ts.output.topic.replication.factor")
    short outputTopicReplicationFactor;

    @ConfigProperty(name = "quarkus.kafka.streams.bootstrap.servers")
    String bootstrapServers;
    @Inject
    ProjectEntityTimeSpan projectEntityTimeSpan;
    @Inject
    ProjectEntityType projectEntityType;
    @Inject
    ProjectEntityClassLabel projectEntityClassLabel;
    @Inject
    ProjectEntityClassMetadata projectEntityClassMetadata;
    @Inject
    CommunityEntityTimeSpan communityEntityTimeSpan;
    @Inject
    CommunityEntityType communityEntityType;
    @Inject
    CommunityEntityClassLabel communityEntityClassLabel;
    @Inject
    CommunityEntityClassMetadata communityEntityClassMetadata;

    @Inject
    BuilderSingleton builderSingleton;
    @Inject
    RegisterInputTopic registerInputTopic;
    @Inject
    OutputTopicNames outputTopicNames;

    Boolean buildTopologyCalled = false;


    //  All we need to do for that is to declare a CDI producer method which returns the Kafka Streams Topology; the Quarkus extension will take care of configuring, starting and stopping the actual Kafka Streams engine.
    @Produces
    public Topology buildTopology() {

        if (!buildTopologyCalled) {
            buildTopologyCalled = true;

            // add processors of sub-topologies
            addSubTopologies();

            // create topics in advance to ensure correct configuration (partition, compaction, ect.)
            createTopics();
        }

        // build the topology
        return builderSingleton.builder.build();
    }


    private void addSubTopologies() {

        var hasTypePropertyTable = registerInputTopic.hasTypePropertyTable();
        var ontomeClassMetadataTable = registerInputTopic.ontomeClassMetadataTable();
        addProjectView(
                hasTypePropertyTable,
                ontomeClassMetadataTable
        );
        addCommunityToolboxView(
                hasTypePropertyTable,
                ontomeClassMetadataTable
        );

    }

    private void createTopics() {
        var admin = new TsAdmin(bootstrapServers);

        createTopicsForProjectView(admin);
        createTopicsForCommunityView(admin);

    }

    private void addProjectView(
            KTable<HasTypePropertyKey, HasTypePropertyValue> hasTypePropertyTable,
            KTable<OntomeClassKey, OntomeClassMetadataValue> ontomeClassMetadataTable
    ) {
        // register input topics as KTables
        var projectEntityTable = registerInputTopic.projectEntityTable();
        var projectTopOutgoingStatementsTable = registerInputTopic.projectTopOutgoingStatementsTable();

        // register input topics as KStreams
        var projectClassLabelTable = registerInputTopic.projectClassLabelTable();

        // add sub-topology ProjectEntityTimeSpan
        projectEntityTimeSpan.addProcessors(
                projectTopOutgoingStatementsTable.toStream(Named.as("project_top_outgoing_statements_table_to_stream"))
        );

        // add sub-topology ProjectEntityType
        projectEntityType.addProcessors(
                projectEntityTable,
                hasTypePropertyTable,
                projectTopOutgoingStatementsTable
        );

        // add sub-topology ProjectEntityClassLabel
        projectEntityClassLabel.addProcessors(
                projectEntityTable,
                projectClassLabelTable
        );

        // add sub-topology ProjectEntityClassMetadata
        projectEntityClassMetadata.addProcessors(
                projectEntityTable,
                ontomeClassMetadataTable
        );
    }

    private void addCommunityToolboxView(
            KTable<HasTypePropertyKey, HasTypePropertyValue> hasTypePropertyTable,
            KTable<OntomeClassKey, OntomeClassMetadataValue> ontomeClassMetadataTable
    ) {
        // register input topics as KTables
        var communityEntityTable = App.this.registerInputTopic.communityEntityTable();
        var communityTopOutgoingStatementsTable = App.this.registerInputTopic.communityTopOutgoingStatementsTable();


        // register input topics as KStreams
        var communityClassLabelTable = App.this.registerInputTopic.communityClassLabelTable();


        // add sub-topology CommunityEntityTimeSpan
        communityEntityTimeSpan.addProcessors(
                communityTopOutgoingStatementsTable.toStream(Named.as("community_top_outgoing_statements_table_to_stream"))
        );

        // add sub-topology CommunityEntityType
        communityEntityType.addProcessors(
                communityEntityTable,
                hasTypePropertyTable,
                communityTopOutgoingStatementsTable
        );

        // add sub-topology CommunityEntityClassLabel
        communityEntityClassLabel.addProcessors(
                communityEntityTable,
                communityClassLabelTable
        );

        // add sub-topology CommunityEntityClassMetadata
        communityEntityClassMetadata.addProcessors(
                communityEntityTable,
                ontomeClassMetadataTable
        );
    }


    private void createTopicsForProjectView(TsAdmin admin) {
        // create output topics (with number of partitions and delete.policy=compact)
        var topics = new ArrayList<String>();
        topics.add(outputTopicNames.projectEntityClassLabel());
        topics.add(outputTopicNames.projectEntityTimeSpan());
        topics.add(outputTopicNames.projectEntityClassMetadata());
        topics.add(outputTopicNames.projectEntityType());
        admin.createOrConfigureTopics(topics, outputTopicPartitions, outputTopicReplicationFactor);
    }


    private void createTopicsForCommunityView(TsAdmin admin) {
        // create output topics (with number of partitions and delete.policy=compact)
        var topics = new ArrayList<String>();
        topics.add(outputTopicNames.communityEntityClassLabel());
        topics.add(outputTopicNames.communityEntityTimeSpan());
        topics.add(outputTopicNames.communityEntityClassMetadata());
        topics.add(outputTopicNames.communityEntityType());
        admin.createOrConfigureTopics(topics, outputTopicPartitions, outputTopicReplicationFactor);
    }


}
